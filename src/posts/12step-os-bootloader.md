---
title: "組み込みOS自作紀 Part1: ブートローダ編"
date: "2017-10-14"
---

仕事でLinuxを触ってるんですが、わからないことがあるとその場で場当たり的に調べているだけで、基礎的な知識がないことをなんとかしたいと思っていました。そこで、OSの理解のためにOSを作ろうと考えたのですが、Linuxを作るのは無理なので適当に簡単なOSを作れないかなと思い探していたら、いい感じの本が見つかりました。

[12ステップで作る組込みOS自作入門](https://www.amazon.co.jp/12%E3%82%B9%E3%83%86%E3%83%83%E3%83%97%E3%81%A7%E4%BD%9C%E3%82%8B%E7%B5%84%E8%BE%BC%E3%81%BFOS%E8%87%AA%E4%BD%9C%E5%85%A5%E9%96%80-%E5%9D%82%E4%BA%95-%E5%BC%98%E4%BA%AE/dp/4877832394)

これは、H8というマイコン専用のOSをフルスクラッチで作っていこうという本で、評判も良さそうなのでやってみることにしました。OS自作本といえば、[30日でできる! OS自作入門](https://www.amazon.co.jp/30%E6%97%A5%E3%81%A7%E3%81%A7%E3%81%8D%E3%82%8B-OS%E8%87%AA%E4%BD%9C%E5%85%A5%E9%96%80-%E5%B7%9D%E5%90%88-%E7%A7%80%E5%AE%9F/dp/4839919844/ref=pd_lpo_sbs_0_t_0?_encoding=UTF8&psc=1&refRID=JXVPAEV05294AK00BC5D)が有名だと思うのですが、12ステップ本の方が新しかったのと、より一般的な技術とかツールを用いてOSを作っていける感じがしたので、12ステップ本を選びました。

OS自作の過程をメモしていきます。まずは、本の前半のブートローダを作るところまで。

## 10/3

Amazonで注文しておいた本が届く。適当に第１章を読んでみる。つまらなそうだったら読むだけで自作はしなくても良いかと思っていたんだが、やる価値のありそうな感じがしたので、OS自作に必要なマイコンや周辺機器を注文する。結局、本と合わせて全部で1万円を超えてしまって悲しい。

## 10/4

http://tkygtr6.hatenablog.com/entry/2018/02/25/201410 に従って環境構築を行う。マイコンがまだ届いていないので、VMの環境設定のみ。

#### VMの準備

VMをダウンロードしてVirtual boxで起動。yumのupdateをしておく。

```shell
# yum -y update
```

#### MacとVMの間で共有フォルダを作成

```shell
# yum -y install epel-release
# yum -y groupinstall "Development Tools"
# yum -y install dkms bzip2 gcc make kernel-devel kernel-headers
```

Menu Bar -> Devices -> Insert Guest Additions CD Image

```shell
# mkdir -p /mnt/cdrom
# mount -r /dev/cdrom /mnt/cdrom
# sh /mnt/cdrom/VBoxLinuxAdditions.run
```

VirtualBoxでイメージを右クリック -> 設定 -> 共有フォルダ -> 右上の+をクリック -> Folder Pathに共有したいパスを入力して「自動マウント」「永続化する」にチェック

#### ssh接続できるように設定

VirtualBoxでイメージを右クリック -> 設定 -> ネットワーク -> アダプタ１ -> 高度 -> ポートフォワードで右上の＋をクリックしてホストポートを2222、ゲストポートを22にしてOK

```shell
# yum install -y openssh openssh-server
# vim /etc/ssh/sshd_config # PermitRootLoginをyesにする
# service sshd start
# chkconfig sshd on # boot後に自動的にsshdを起動するようにする
 
// Macから
$ ssh -p 2222 root@localhost
```

## 10/6

マイコンが届いたのでHello Worldを試みる。最近の日本では、amazon以外の通販でも2日とかで荷物が届くんですね。

#### マイコンの接続

マイコンを電源ケーブルに接続し、ディップスイッチを3以外ONの状態にしてシリアルケーブルをMacに接続する。接続によって、Macで`/dev`以下にファイルが増えるか（デバイスが認識されているか）を確認する。接続前と比較すると`/dev/cu.usbserial-*`というファイルが新しく増えていたので、Macではマイコンを認識できていそう。

続いてVMからデバイスを認識できるようにする。VirtualBoxでイメージを右クリック -> 設定 -> ポート -> USBで右上の＋をクリックして「FTDI USB HS SERIAL CONVERTER」を追加。VMを再起動して、`/dev/serial/by-id/usb-FTDI_USB_HS_SERIAL_CONVERTER_*`というファイルが出来ていればOK。

#### プログラムの写経

以下のファイルを本からひたすら写経する。これらのコードはWebで配布されているが、せっかくなので自分で打つ。

- `main.c`：Hello worldプログラム
- `startup.s`：スタートアップ
- `vector.c`：割り込みベクタの設定
- `lib.h`, `lib.c`：ライブラリ
- `serial.h`, `serial.c`：シリアルデバイス用のデバイスドライバ
- `defines.h`：各種定義
- `ld.scr`：リンカスクリプト
- `Makefile`

`Makefile`のデバイスファイル名を自分の環境のものに書き換えることに注意する。

#### マイコンに書き込み

VMで作成したプログラムをマイコンに書き込む。まずは、書き込みを行うためのソフトである`h8write`を、適切なディレクトリでコンパイルしておく。

```
# cp /home/user/h8write.c tools/
# cd tools
# gcc h8write.c -o h8write
```

`Makefile`があるディレクトリに移動して`make write`を打つ。これで`h8write`が今回書いたコードをコンパイルしたもの（`kzload`）をマイコンのROMに書き込んでくれる。

```shell
# make write
../../tools/h8write/h8write -3069 -f20 kzload.mot /dev/serial/by-id/usb-FTDI_USB_HS_SERIAL_CONVERTER_FT2RGIA5-if00-port0
H8/3069F is ready!  2002/5/20 Yukio Mituiwa.
writing
WARNING:This Line dosen't start with"S".
Address Size seems wrong
WARNING:This Line dosen't start with"S".
Address Size seems wrong
.....
EEPROM Writing is successed.
```

途中何度かエラーが出たが、VMとマイコンをそれぞれ再起動してたら何もしなくても直って書き込みが成功した（why...）。

#### Hello World!

マイコンのディップスイッチを1, 3のみONにする。
screenでマイコンに接続してリセットボタンを押すと`Hello World!`が出力される！ありがとう。

#### 勉強：メモリマップドI/O

- マイコンは、上でHello worldに使ったシリアル通信など、外部とインターフェースと入出力を行う。この時、プログラムを書いてCPUに全ての入出力をまかせるのは大変なので、専用のICチップであるコントローラにまかせる
- そのコントローラの制御は、コントローラが持つレジスタ経由で行う
	- 例えば、シリアルコントローラの特定のレジスタに１バイトを書き込むと、そのバイトがシリアル送信される。シリアル通信のパラメータも、別の特定のレジスタのビットを立てたり落としたりで設定する
- レジスタにアクセスするために、コントローラのそれぞれのレジスタにメモリアドレスを１つ割り当てる。例えば、16個のレジスタを持つシリアルコントローラに`0x10000000 - 0x1000000f`というアドレスを割り当て、メモリと同じようにアクセスする。C言語のプログラムから見ると、変数の値を読んだり書いたりすることでレジスタ入出力ができ、ひいては外部との通信ができることになる
	- これがメモリマップドI/Oという概念

![メモリマップどI/O](https://gyazo.com/fd01a45c89210a4983918c635bec3b1b)

```c
/* プログラム例 */
char c;
volatile char *register1 = (char *)0x1000000;
   
c = *register1; /* 読み出し */
*register1 = 0x01; /* 書き込み */
```

- メモリマップドI/Oのコードは、同じ変数への連続した代入など、通常のC言語のコードとして読むと無駄な操作をすることがある。これが最適化されてしまわないように、接頭辞`volatile`をつける必要がある

#### H8のシリアルコントローラのレジスタ
- 上の図は外部にシリアルコントローラがある場合だが、H8ではコントローラもCPUに組み込まれていて、固定のアドレスが与えられている。`serial.c`でそのアドレスを使っている
- H8はシリアルコントローラをSCI0, SCI1, SCI2の３つ持つ。マイコンボードのシリアルコネクタに接続されているのはSCI1なので、SCIを操作するとシリアル経由の入出力が行える

![レジスタ](https://gyazo.com/8a816e1d9ab6b4b0e9563c1a1e4b48cc)

#### H8でシリアルへの１文字出力
- 主に使うレジスタは２つ
	- SSR（シリアルステータスレジスタ）：７ビット目が送信完了ビットで、送信完了で１になる
	- TDR（トランスミットデータレジスタ）：送信したい１バイトを書き込む

- １文字出力する流れ
	- SSRの送信完了ビットが立っていることを確認
  - TDRに送信したい文字を書き込む
  - SSRの送信完了ビットを落とす
  - 送信が完了すると、SCIが買ってに送信完了ビットを立ててくれる

#### ライブラリ関数の追加

- 以下の関数を`lib.c`に追加した
	- `memset`
	- `memcpy`
  - `memcmp`
  - `strlen`
  - `strcpy`
  - `strcmp`
  - `strncmp`
  - `putxval`

- `main.c`が`putxval`を使うように変更して、再び`make write`してマイコンに書き込む。実行してみて、`putxval`が正しく動作することを確認する。ディップスイッチの切り替えを忘れないように注意

#### 勉強：スタートアップと割り込みベクタ

- マイコンの電源を入れると`main()`関数が実行されているが、これはなぜか？

- CPUには割り込みという機能がある。CPUがある処理をしている最中に割り込みがある（CPUの割り込み線に電圧がかかる）と割り込みハンドラが実行される
- 割り込み時に実行されるハンドラを指定するために、割り込み発生時にどのアドレスから実行されるかを特定のアドレス（＝割り込みベクタ）に書いておく必要がある
	- H8の場合は割り込みベクタは`0x000000 - 0x0000ff`
- 電源ONも割り込みの一種で、割り込みベクタの先頭に書いてあるハンドラが実行される

- 今回のプログラムで`main()`関数が実行される理由は以下
	- リンカスクリプトの`ld.scr`で`vector.o`を`0x000000 - 0x0000ff`に配置しているため、これが割り込みベクタになる
 	- `vector.c`を見ると、先頭が`start`になっているため、電源ON時には`start`が実行されることがわかる。この`start`は、スタートアップの`startup.s`内に書かれている`_start`のことである
	- `_start`を見ると、`main()`にジャンプしている

## 10/7

#### 静的変数が書き換えられない問題の確認

- 現在のセットアップだと、自動変数は普通に買い換えられるが静的変数が書き換えられないらしい
	- 自動変数：関数内部で定義された変数。スタック内部に存在するので、プログラムのある部分が終わったら捨てられる
  - 静的変数：関数の外で定義された変数や関数の中で`static`をつけて定義された変数。プログラム動作中は常に存在し続け、メモリのどこかに固定で割り当てる必要がある

- 静的変数を書き換えるように`main.c`を変更して確認してみると、確かに変更したはずの変数の値が変わっていなかった

```c
volatile int a = 100;
   
int main(void) {
  serial_init(SERIAL_DEFAULT_DEVICE);
   
  putxval(a, 8); puts("\n");
  a = 80;
  putxval(a, 8); puts("\n");
   
	while (1)
		;
   
	return 0;
}
```

#### 勉強：メモリ構成と領域

- メモリはROMとRAMに分けられる
 	- ROM：書き込み不可。電源OFFでも内容が保持される
  - RAM：書き込み可能。電源OFFで内容が失われる

- H8では決まったアドレスにROMとRAMが配置されている

![H8のROM/RAM](https://gyazo.com/e9095fd311d88f6395ea77b659c23a84)

- CPUはメモリ上にあるプログラムしか実行できないので、実行時には実行形式ファイルがメモリに展開される
- 展開されたプログラムはいくつかの領域から構成される
 	- テキスト領域：CPUが実行する機械語コードが置かれる
  - データ領域：初期値を持つ静的変数が置かれる
  - BSS領域：初期値を持たない静的変数が置かれる
  	- データ領域とBSS領域の違いは、実行形式ファイル内に値を保持しておく必要があるかどうか
  	- BSS領域は値の保持が必要ないので、実行形式ファイルはサイズを持つだけで実体はない。実際の領域の確保はプログラムの実行時に行われる

- 疑問：BSS領域に「サイズ情報だけ格納されている」というがBSS領域全体のサイズのことなのか、１つ１つの変数のサイズのことなのか

- H8の実行形式ファイルはELF形式。ELF形式の内部はセクションという単位で区切られていて、それぞれのセクションがメモリ領域に対応する
	- `.text`セクションはテキスト領域
  - `.data`セクションはデータ領域

- ELF形式のファイルは、`readelf`コマンドで内容を読むことができる

```shell
   # readelf -a kzload.elf
   ELF Header:
     Magic:   7f 45 4c 46 01 02 01 00 00 00 00 00 00 00 00 00
     Class:                             ELF32
   
  	...
    
   Section Headers:
     [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
     [ 0]                   NULL            00000000 000000 000000 00      0   0  0
     [ 1] .vectors          PROGBITS        00000000 000074 000100 00  WA  0   0  4
     [ 2] .text             PROGBITS        00000100 000174 000332 00  AX  0   0  2
     [ 3] .rodata           PROGBITS        00000432 0004a6 00001f 01 AMS  0   0  1
     [ 4] .data             PROGBITS        00000454 0004c8 000010 00  WA  0   0  4
     [ 5] .shstrtab         STRTAB          00000000 0004d8 000038 00      0   0  1
     [ 6] .symtab           SYMTAB          00000000 000650 0003c0 10      7  43  4
     [ 7] .strtab           STRTAB          00000000 000a10 000160 00      0   0  1
     
   ...  
   
  	Symbol table '.symtab' contains 60 entries:
      Num:    Value  Size Type    Bind   Vis      Ndx Name
        0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
        1: 00000000     0 SECTION LOCAL  DEFAULT    1
        2: 00000100     0 SECTION LOCAL  DEFAULT    2
        3: 00000432     0 SECTION LOCAL  DEFAULT    3
        4: 00000454     0 SECTION LOCAL  DEFAULT    4
        5: 00000000     0 FILE    LOCAL  DEFAULT  ABS vector.c
   ...
       44: 00000000   256 OBJECT  GLOBAL DEFAULT    1 _vectors
       45: 000001a2    46 NOTYPE  GLOBAL DEFAULT    2 _putc
       46: 00000454     2 OBJECT  GLOBAL DEFAULT    4 _a
       47: 000001d0    36 NOTYPE  GLOBAL DEFAULT    2 _puts
       48: 000003b8    36 NOTYPE  GLOBAL DEFAULT    2 _serial_is_send_enable
       48: 000003b8    36 NOTYPE  GLOBAL DEFAULT    2 _serial_is_send_enable
       49: 00000272    40 NOTYPE  GLOBAL DEFAULT    2 _memcpy
       50: 00000258    26 NOTYPE  GLOBAL DEFAULT    2 _memset
       51: 00000100     0 NOTYPE  GLOBAL DEFAULT    2 _start
       52: 00000382    54 NOTYPE  GLOBAL DEFAULT    2 _serial_init
       53: 000001f4   100 NOTYPE  GLOBAL DEFAULT    2 _putxval
       54: 000002f8    26 NOTYPE  GLOBAL DEFAULT    2 _strcpy
       55: 0000029a    68 NOTYPE  GLOBAL DEFAULT    2 _memcmp
       56: 00000346    60 NOTYPE  GLOBAL DEFAULT    2 _strncmp
       57: 000002de    26 NOTYPE  GLOBAL DEFAULT    2 _strlen
       58: 000003dc    86 NOTYPE  GLOBAL DEFAULT    2 _serial_send_byte
       59: 0000010c   150 NOTYPE  GLOBAL DEFAULT    2 _main
```

- `Section headers`を見ると、それぞれのセクションが割り当てられるアドレスが書いてある
	- 例えば、`.text`がアドレス`0000010c`から定義されているので、メモリマップと見比べるとROMにテキスト領域があることがわかる
- Symbol table`を見ると、変数や関数がマップされているアドレスもわかる
	- 例えば、`_start`、`_main`、`_memcpy`などがテキスト領域に含まれていることが読み取れる
  - 静的変数の`_a`はデータ領域にある。自動変数はスタックに割り当てられるため、ここでは出力されない
- 以上を見ると、テキスト領域がROMに存在することからCPUはROMから命令を読み取って動いていることがわかる

- 静的変数が書き換えられないのは、静的変数がデータ領域にあり、データ領域がRead OnlyのROMの上に書かれているから。書き換えができるようにするにはRAMの上にデータ領域を置く必要がある

#### 勉強：リンカスクリプト

- そもそもプログラムのどの部分をどのアドレスに配置するのかを決めるのがリンカスクリプト。現状のリンカスクリプト`ld.scr`をもう一度見て理解してみる。

```
   /* OUTPUT_FORMAT("elf32-h8300") */
   OUTPUT_ARCH(h8300h)
   ENTRY("_start")
   
   SECTIONS
   {
   	// ロケーションカウンタ。現在のアドレスを表す
    	// 以降のセクションはゼロ番地（0x0）から配置されていくことになる
   	. = 0x0;
   
   	// ".vectors"セクションを作成し、vector.oの.dataセクションを配置する
   	.vectors : {
   		vector.o(.data)
   	}
   
   	// 全ての*.oファイルの.textセクションの内容を.textセクションに配置
   	.text : {
   		*(.text)
   	}
   
   	// roはread onlyの意味
    // const定義の変数や文字列リテラルを.rodataセクションに配置
   	.rodata : {
   		*(.strings)
   		*(.rodata)
   		*(.rodata.*)
   	}
   
   	// 全ての*.oファイルの.dataセクション/.bssセクションの内容を.dataセクション/.bssセクションに配置
    // .rodataの直後のアドレス（ROM）に割り当てられている
   	.data : {
   		*(.data)
   	}
   	.bss : {
   		*(.bss)
   		*(COMMON)
   	}
   }
```
   
- `.data`の直前に`. = 0xffbf20`（RAMのアドレス）を書いておけば静的変数が書き換え可能になるように思えるが、`h8write`がROMにしか書き込めないためデータが書き込めないことになってしまう。仮に書き込めたとしても、電源を落とした時に値が消えてしまうので困る

#### 静的変数の書き換えを可能にする

- 以下の操作で、静的変数を書き換えることができるようになる
 	- 変数の初期値はROMに保存するようにする。`h8write`はROM上にデータを書き込む
  - プログラム起動直後に、ROM上の変数の初期値をRAM上にコピーする
  - プログラムはその後、RAM上の変数にアクセスする

- ROM上の変数のアドレスを物理アドレス（PA）、RAM上のアドレスを論理アドレス/仮想アドレス（VA）と呼ぶ
 	- 物理/仮想アドレスは仮想メモリの用語だが、関係ない

- `readelf`の出力を見てみると、`Program Headers`の欄に`VirtAddr`、`PhysAddr`というカラムがあるのがわかる
 	- 現状だと、VA = PAになっているが、これをVA != PAにすれば良いということになる
  - 疑問：VAとPAの使い分けを一言で言うと？　VAはリンカ用でPAはローダ用？

- `Program Header`の欄はセグメントの一覧になっている。セグメントはELF形式が持つ管理単位
- プログラム実行時にはローダがセグメント情報を参照しメモリ上に展開するロードという作業を行う。ロード時にはセクションではなくセグメントが参照されることに注意
 	- セクション：リンク時に必要な情報を持つ
  - セグメント：実行時に必要な情報を持つ
  	- 参考： https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format
- セグメントは0 - n個のセクションを持つことができる

- 静的変数の書き換えを可能にするために、プログラムに以下の修正を加える（変更のPR：https://github.com/ymr-39/12os/pull/1/files）
	- `ld.scr`
  	- メモリ領域を指定してどのセクションがどの領域に属するのかを指定
  	- C言語のプログラムから使うために、メモリ上の位置をシンボルに保存
   	- `.data`セクションと`.bss`セクションについてはVAとPAを両方指定する
   	- 疑問：`MEMORY`コマンドで指定した領域＝メモリ領域（テキスト、データ、BSS）？ それにしてはBSSとテキストがない
  - `main.c`
  	- プログラム起動時にROM上のデータをRAM上にコピーする
  	- 静的変数の書き換えを試すコードを挿入
  - `startup.s`：スタックの設定を変更
  	- スタック領域を指定するのにアドレス直書きでなく`ld.scr`で作ったシンボルの名前を利用

- 何回か試行錯誤したのち、無事静的変数の書き換えができることを確認した

#### ブートローダ

- いままでプログラムを更新するたびにH8のROMに書き込んできたが、フラッシュROMの書き込み回数には制限がある。そこで、ROMには「実行形式ファイルをダウンロードしてRAM上に展開して起動するプログラム」であるブートローダを書き込んでおき、起動を任せる形式を取ることにする
- ROMへの書き込み回数が減る代わりに、即座にOSを起動することができなくなるというデメリットがある。実際のOS開発では開発はブートローダを上記の方法で使うが、出荷時にOS本体もROM上に格納し、ブートローダがそれをRAM上に展開するということを行う

- 今回開発するブートローダには次の機能が必要になる
 	- シリアル経由で実行形式ファイルをダウンロードし、いったんRAMに保存する
  - 保存したファイルを適切にRAM上に展開する
  - 展開したファイルを実行する
	- ダウンロードにはシリアル経由のファイル転送プロトコルであるXMODEMを使う。XMODEMプロトコルは以下
 		- 送信側
  		- 受信側から定期的に送信されるNAKを受けたら固定長のブロック単位で送信を開始する
   		- １ブロック送信したらACKかNAKが帰ってくるのを待つ
   		- ACKなら次のブロックを送信する
    	- NAKなら同じブロックを再送する
  		- 全てのデータを送信したらEOTを送信し、ACKが帰ってきたら終了する
   		- 中断したい場合はCANを送信し、CANが帰ってきたら中断する
  	- 受信側
  		- 受信準備ができたらNAKを送信する
   		- SOHを受けたらブロック受信し、成功したらACKを返す。チェックサムエラーなど失敗があればNAKを返す
   		- EOTを受けたらACKを返して終了する
   		- 中断したい場合はCANを送信し、CANが帰ってきたら中断する
		- ブロックの構成要素
  		- SOH（1バイト）
   		- ブロック番号（1バイト、1からの通し番号）
   		- ブロック番号をビット反転したもの（1バイト）
   		- データ（128バイト）
   		- データ部のチェックサム（1バイト）

## 10/8

#### XMODEMによるファイルの送信

- XMODEMの実装を行う（変更のPR：https://github.com/ymr-39/12os/pull/2）
 	- `xmodem.h`、`xmodem.c`（新規追加）
  	- XMODEMの仕様に合わせてデータを受信
  - `main.c`
  	- 操作をインタラクティブに変更してファイルのロードやメモリダンプができるようにする
  - `ld.scr`
  	- ダウンロードした実行形式ファイルを一時的においておくバッファ領域を追加
  - `serial.h`、`serial.c`
  	- バイトを受け取るための関数を追加
  - `lib.h`、`lib.c`
  	- `serial.c`に書いたバイトを受け取るための関数をラップする関数を追加
  - Makefile

- コードが完成したら`h8write`でマイコンに書き込む
- `screen`でマイコンに接続し、リセットボタンを押すとプロンプトが表示されるようになっている。`load`と入力してから`ctrl+a` -> `: exec !! sx defines.h`と打つと`defines.h`がマイコンに送信される。送信されたファイルは`dump`でメモリダンプを表示することができる

#### アセンブラプログラミング

- OS自作でアセンブラではないと記述できない部分
 	- スタートアップ
  - 割り込みの入口と出口
  - スレッドのディスパッチ

- 関数呼び出しで使われるスタック構造は、以下のようにポインタを使って実装されている。
 	- 現在、メモリ上のどこまでを利用しているかを示すポインタを用意する（＝スタックポインタ）
  - 関数が呼ばれると、自動変数のためにメモリが必要になるのでポインタをずらす。ずらした分の領域は関数が自由に使って良い
  - その関数の中で関数が呼ばれた場合は、さらにポインタをずらす
  - 関数から戻るときは、ポインタを戻す

- アセンブラの命令は、単純なものが多い
 	- 「メモリからレジスタにデータを読み込む」
  - 「レジスタのデータをメモリに書き込む」
  - 「２つのレジスタの値を加算し別のレジスタに書き込む」

- 例えば、`c = a + b`というC言語の命令は、アセンブラでは以下のようになる
 	- 変数`a`の位置のメモリの値をレジスタ１に読む
  - 変数`b`の位置のメモリの値をレジスタ２に読む
  - レジスタ１の値とレジスタ２の値を足してレジスタ３に書き込む
  - レジスタ３の値を変数`c`の位置のメモリに書き込む

- CPUのレジスタの数は8 - 32個程度

- プログラムカウンタはCPUが現在実行している命令のアドレスを指す
 	- 命令が実行されるたびにプログラムカウンタが次の命令を指す位置まで加算されることでメモリ上の命令が逐次実行されていく
  - ジャンプ命令（条件分岐の場合はブランチ命令）では、次に実行される命令までジャンプするが、これはプログラムカウンタに値を代入することで行われる

- 機械語の命令は数値で表されるが、この数値をオペコードという
 	- 例えば、`0x01`はロードを表すオペコード
 	- アセンブラでは、人間が読みやすいようにオペコードをニーモニックと呼ばれる文字列に置き換えて表す

## 10/13

#### 記憶を取り戻す

久しぶりすぎて全ての記憶がなくなってたので、今までのメモ（このページ）とか本をなんとなく読み返す。そのあと現状のコードを読んだらだいたい思い出した。

#### 勉強：ELF形式

- ELF形式は実行形式ファイルのフォーマットの一つ

- セクションはリンカのために、セグメントはローダのためにある。以下がcプログラムのコンパイルから実行までの流れ
	- 個々の`*.c`ファイルをコンパイルして、オブジェクトファイル`*.o`ができる。この`.o`ファイルはELF形式

- ELF形式では、機械語コード、データなどはごちゃ混ぜにならずにそれぞれの領域（セクション）にまとめてある
 	- 複数の`.o`ファイルをセクションごとにまとめる（リンク）ことで、実行形式ファイルが生成される
 	- リンク時には、「セグメント」が生成されるので、実行形式ファイルはセグメントを持つ。セグメントは、複数個のセクションを含むことが多い
	- リンク前の`.o`ファイルはセクションは持っているがセグメントは持っていない
	- プログラムの実行時には、ローダが実行形式ファイルをメモリ上に展開する。この時、セグメントがメモ展開の単位として使われる

- ELF形式の内部構造は以下
 	- ELFヘッダ：マジックナンバ、OSの種類やELFのバージョンなど
  - プログラムヘッダテーブル：セグメントのメタ情報のリスト
  - 複数のセグメント：本体
  - セクションヘッダテーブル：セクションのメタ情報のリスト

#### ELF形式ファイルの解析機能の追加

- ELF形式のファイルをメモリ上に展開するための前準備として、まずはELF形式を解析するプログラムを追加する（変更のPR：https://github.com/ymr-39/12os/pull/3）
 	- `elf.h`、`elf.c`：ELF形式のELFヘッダ/プログラムヘッダテーブルを読む機能を追加
  - `main.c`：`run`と入力されるとELF形式解析機能を呼ぶように変更

## 10/14

#### OSになるファイルの追加

- これまでブートローダを開発してきたが、これからはOSにするプログラムと並行して開発していく。まずは、OSとなるコードで`Hello world`をする（変更のPR：https://github.com/ymr-39/12os/pull/3）

- OS
  - `lib.*`とか`serial.*`：ブートローダからコピペ
  - `main.c`：`Hello world`をする
  - `ld.scr`
- ブートローダ
	- `elf.h`、`elf.c`：ELF形式の解析だけしていたのを、メモリ上に展開するようにする。また、OSのエントリポイントのアドレスを返すようにする
	- `main.c`：`elf.c`から得たOSのエントリーポイントに処理を渡す
  - 疑問：バッファ領域にダンプしたものとちゃんとメモリ上に展開したものはどう違うのか？
  	- 以下で`Offset`がダンプされたものの話で`PhysAddr`が展開されるべきものの話？
    	
```
      Program Headers:
        Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
        LOAD           0x000094 0x00000000 0x00000000 0x00100 0x00100 RW  0x1
        LOAD           0x000194 0x00000100 0x00000100 0x00877 0x00877 R E 0x1
        LOAD           0x000a0c 0x00fffc20 0x00000977 0x00010 0x00024 RW  0x1
```
